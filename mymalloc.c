#include <stdio.h>
#include "mymalloc.h"

/* This array will keep the temprory values generated by num_to_array function,
   a given integer is converted to two characters and stored in this temporary array.*/
unsigned char num_string[2];

/* Before call for MyMalloc function for the first time, memory should be initialized
   using "initialize_memory()" function. This integer "memory_initialized" variable will show 
   store whether the memory is initialized or not. If initialozed, it will be set to
   1, if not(by default) it will be 0.*/
int memory_initialized = 0;

/* These variables will keep values of properties of a certain memory block.*/
char current_block_status;
int current_block_size;
int current_block_next;
int current_block_start_indx;

/* This function will convert a given integer in to two character values and store them
   in num_string char array.*/
void num_to_char_array(int value)
{
    if(value <= 19995 && value > 0)
    {
        num_string[0] = value / 100;
        num_string[1] = value % 100;
    }else{
        num_string[0] = '\0';
        num_string[1] = '\0';
    }
}

/* This function will convert the characters stored in num_string array in to originale
   integer value and return it.*/
int char_array_to_num()
{
    return (((int)num_string[0] * 100) + (int)num_string[1]);
}

/* This function will initialize the memory array.*/
void initialize_memory()
{
    memory[0] = '0';
    num_to_char_array(19995);
    memory[1] = num_string[0];
    memory[2] = num_string[1];
    num_to_char_array(0);
    memory[3] = num_string[0];
    memory[4] = num_string[1];
}

/* This function will search for a free memory block, return starting index of a free memory block if possible.*/
int find_free_block(int size_of_mem)
{
    /* If a minus value or a larger value than the total memory size is asked for,
       will return -1.(In this case, largest available memory size will be 19995 as
       5bytes from 20000bytes already allocated in memory initialization process.)*/
    if(size_of_mem <= 0 || size_of_mem >=19996)
    {
        return -1;
    }else{
    /* This will be used to break the while loop. When a suitable free block found
       found_free will be set to 1. */
        int found_free = 0;

        while(!found_free)
        {
            if(current_block_status == '0' && current_block_size >= size_of_mem)
            {
                found_free = 1;
                return current_block_start_indx;
            }else if(current_block_next != 0){
                current_block_status = memory[current_block_next - 5];
                num_string[0] = memory[current_block_next - 4];
                num_string[1] = memory[current_block_next - 3];
                current_block_size = char_array_to_num();
                current_block_start_indx = current_block_next;
                num_string[0] = memory[current_block_next - 2];
                num_string[1] = memory[current_block_next - 1];
                current_block_next = char_array_to_num();
            }else{
                return -1;
            }
        }
    }
}

/* This function will merge near by free memory blocks.*/
void free_blocks_merger()
{
    char cur_block_status;
    int cur_block_size;
    int cur_block_next;
    int cur_block_start_indx;

    char nxt_block_status;
    int nxt_block_size;
    int nxt_block_next;
    int nxt_block_start_indx;

    /* Current block's attributes.*/
    cur_block_start_indx = 5;
    cur_block_status = memory[0];

    num_string[0] = memory[1];
    num_string[1] = memory[2];
    cur_block_size = char_array_to_num();

    num_string[0] = memory[3];
    num_string[1] = memory[4];
    cur_block_next = char_array_to_num();
	
    while(cur_block_next != 0){
        nxt_block_start_indx = cur_block_next;
        nxt_block_status = memory[nxt_block_start_indx - 5];
        num_string[0] = memory[nxt_block_start_indx - 4];
        num_string[1] = memory[nxt_block_start_indx - 3];
        nxt_block_size = char_array_to_num();
        num_string[0] = memory[nxt_block_start_indx - 2];
        num_string[1] = memory[nxt_block_start_indx - 1];
        nxt_block_next = char_array_to_num();
        
    /* If two near by free blocks found, those two will be merged and current block's
       attributes will be re-calculated.*/
        if((cur_block_status == '0') && (nxt_block_status == '0'))
        {
            cur_block_size = cur_block_size + nxt_block_size + 5;
            cur_block_next = nxt_block_next;
            num_to_char_array(cur_block_size);
            memory[cur_block_start_indx - 4] = num_string[0];
            memory[cur_block_start_indx - 3] = num_string[1];
            num_to_char_array(cur_block_next);
            memory[cur_block_start_indx - 2] = num_string[0];
            memory[cur_block_start_indx - 1] = num_string[1];
        }else{
    	/* If current block is not a free one or next block is not free, next block will be
    	   pointed as current block.*/
            cur_block_status = nxt_block_status;
            cur_block_size = nxt_block_size;
            cur_block_next = nxt_block_next;
            cur_block_start_indx = nxt_block_start_indx;
        }
    }
}

/* This function will allocate a memory block from memory char array(if possible) and
   will return the starting index of the memory block. If impossible, will return -1.*/
void * MyMalloc(int size)
{
	/* If memory is not initialized, following block will run.*/
	if(memory_initialized == 0){
		memory_initialized = 1;
		initialize_memory();
		/* Initialize the starting point to search a free block in the memory.*/
    	current_block_status = memory[0];
    	num_string[0] = memory[1];
    	num_string[1] = memory[2];
    	current_block_size = char_array_to_num();
    	num_string[0] = memory[3];
    	num_string[1] = memory[4];
    	current_block_next = char_array_to_num();
    	current_block_start_indx = 5;

    	/* This will hold the starting index of the new memory chunk to be produced.*/
    	int new_block_starting_indx;
    	new_block_starting_indx = find_free_block(size);

    	if(new_block_starting_indx == -1){
        	return (void * )-1;
    	}else{
        	/* Free block's attributes are collected in to program in here.*/
        	current_block_status = memory[new_block_starting_indx - 5];
        	num_string[0] = memory[new_block_starting_indx - 4];
        	num_string[1] = memory[new_block_starting_indx - 3];
        	current_block_size = char_array_to_num();
        	num_string[0] = memory[new_block_starting_indx - 2];
        	num_string[1] = memory[new_block_starting_indx - 1];
        	current_block_next = char_array_to_num();
        	current_block_start_indx = new_block_starting_indx;

        	/* Memory blocks less than 5 bytes size will not be created. It such situation occurs,
           	   those less byte block is also appended to the originale block.(No "No Man's Island"s!).
               Else, the originale memory block will be fragmented for two parts and a new free block
               will be created with the rest of memory space gained by fragmenting the originale one.*/
        	if((current_block_size - size) <= 5){
            	memory[current_block_start_indx - 5] = current_block_status = '1';
            	num_to_char_array(current_block_size);
            	memory[current_block_start_indx - 4] = num_string[0];
            	memory[current_block_start_indx - 3] = num_string[1];
            	num_to_char_array(current_block_next);
            	memory[current_block_start_indx - 2] = num_string[0];
            	memory[current_block_start_indx - 1] = num_string[1];
            	return (void *)&memory[current_block_start_indx];
        	}else{
            	memory[current_block_start_indx - 5] = current_block_status = '1';
            	num_to_char_array(size);
            	memory[current_block_start_indx - 4] = num_string[0];
            	memory[current_block_start_indx - 3] = num_string[1];

            	/* Newly fragmented block's attributes are created here.*/
            	char new_frg_block_status = '0';
            	int new_frg_block_size = current_block_size - size - 5;
            	int new_frg_block_start_indx = current_block_start_indx + size + 5;
            	int new_frg_block_next = current_block_next;
            	current_block_next = new_frg_block_start_indx;
            	num_to_char_array(current_block_next);
            	memory[current_block_start_indx - 2] = num_string[0];
            	memory[current_block_start_indx - 1] = num_string[1];

            	memory[new_frg_block_start_indx - 5] = '0';
            	num_to_char_array(new_frg_block_size);
            	memory[new_frg_block_start_indx - 4] = num_string[0];
            	memory[new_frg_block_start_indx - 3] = num_string[1];
            	num_to_char_array(new_frg_block_next);
            	memory[new_frg_block_start_indx - 2] = num_string[0];
            	memory[new_frg_block_start_indx - 1] = num_string[1];

            	return (void *)&memory[current_block_start_indx];
        	}
    	}
	/* If memory is initialized, following block will run.*/	
	}else if(memory_initialized == 1){
		/* Initialize the starting point to search a free block in the memory.*/
    	current_block_status = memory[0];
    	num_string[0] = memory[1];
    	num_string[1] = memory[2];
    	current_block_size = char_array_to_num();
    	num_string[0] = memory[3];
    	num_string[1] = memory[4];
    	current_block_next = char_array_to_num();
    	current_block_start_indx = 5;

    	/* This will hold the starting index of the new memory chunk to be produced.*/
    	int new_block_starting_indx;
    	new_block_starting_indx = find_free_block(size);

    	if(new_block_starting_indx == -1){
        	return (void *)-1;
    	}else{
        	/* Free block's attributes are collected in to program in here.*/
        	current_block_status = memory[new_block_starting_indx - 5];
        	num_string[0] = memory[new_block_starting_indx - 4];
        	num_string[1] = memory[new_block_starting_indx - 3];
        	current_block_size = char_array_to_num();
        	num_string[0] = memory[new_block_starting_indx - 2];
        	num_string[1] = memory[new_block_starting_indx - 1];
        	current_block_next = char_array_to_num();
        	current_block_start_indx = new_block_starting_indx;

        	/* Memory blocks less than 5 bytes size will not be created. It such situation occurs,
           	   those less byte block is also appended to the originale block.(No "No Man's Island"s!).
               Else, the originale memory block will be fragmented for two parts and a new free block
               will be created with the rest of memory space gained by fragmenting the originale one.*/
        	if((current_block_size - size) <= 5){
            	memory[current_block_start_indx - 5] = current_block_status = '1';
            	num_to_char_array(current_block_size);
            	memory[current_block_start_indx - 4] = num_string[0];
            	memory[current_block_start_indx - 3] = num_string[1];
            	num_to_char_array(current_block_next);
            	memory[current_block_start_indx - 2] = num_string[0];
            	memory[current_block_start_indx - 1] = num_string[1];
            	return (void *)&memory[current_block_start_indx];
        	}else{
            	memory[current_block_start_indx - 5] = current_block_status = '1';
            	num_to_char_array(size);
            	memory[current_block_start_indx - 4] = num_string[0];
            	memory[current_block_start_indx - 3] = num_string[1];

            	/* Newly fragmented block's attributes are created here.*/
            	char new_frg_block_status = '0';
            	int new_frg_block_size = current_block_size - size - 5;
            	int new_frg_block_start_indx = current_block_start_indx + size + 5;
            	int new_frg_block_next = current_block_next;
            	current_block_next = new_frg_block_start_indx;
            	num_to_char_array(current_block_next);
            	memory[current_block_start_indx - 2] = num_string[0];
            	memory[current_block_start_indx - 1] = num_string[1];

            	memory[new_frg_block_start_indx - 5] = '0';
            	num_to_char_array(new_frg_block_size);
            	memory[new_frg_block_start_indx - 4] = num_string[0];
            	memory[new_frg_block_start_indx - 3] = num_string[1];
            	num_to_char_array(new_frg_block_next);
            	memory[new_frg_block_start_indx - 2] = num_string[0];
            	memory[new_frg_block_start_indx - 1] = num_string[1];

            	return (void *)&memory[current_block_start_indx];
        	}
    	}
	}
}

/* This function will free the memry block starts from a given memry block and return 1.
   If such memory block does not exist, will return -1.*/
void MyFree(void * indx_pointer)
{
	int indx = indx_pointer - (void *)memory;

    if((indx > 0) && memory[indx - 5] == '1')
    {
        memory[indx - 5] = '0';
        free_blocks_merger();
    }
}

/* This function will print memory to console.*/
void print_memory()
{
    int x;
    for(x = 0; x < 20000; x++)
    {
        printf("memory[%d] = %c\n", x, memory[x]);
    }
    printf("///////////////////////////////////\n");
}
